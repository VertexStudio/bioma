<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RAG Server Chat</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.3.0/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />

    <style>
      :root {
        --primary: #ff00a0;
        --primary-hover: #e4008e;
        --text-primary: #ffffff;
        --text-secondary: #e5e7eb;
        --text-muted: #a0a0a0;
        --bg-main: #121214;
        --bg-secondary: #1c1c1f;
        --border-color: #2a2a2d;
        --font-family: "JetBrains Mono", monospace;
        --sidebar-width: 250px;
        --surrealist-gradient: linear-gradient(
          135deg,
          var(--primary) 0%,
          #9600ff 100%
        );
      }

      @font-face {
        font-family: "JetBrains Mono";
        src: url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap");
      }

      html,
      body {
        background-color: var(--bg-main);
        color: var(--text-primary);
        font-family: var(--font-family);
        margin: 0;
        padding: 0;
      }

      /* Wrap main content to avoid overlapping the sidebar */
      #main-content {
        width: 800px;
        margin: 20px auto;
        padding: 20px;
        padding-bottom: 80px;
        transition: all 0.3s ease;
        position: relative;
      }

      #main-content.sidebar-visible {
        width: 800px;
        margin-left: calc(50% - 400px - var(--sidebar-width) / 2);
      }

      /* Sidebar styling */
      #sidebar {
        position: fixed;
        top: 0;
        right: calc(-1 * (var(--sidebar-width) + 20px));
        width: var(--sidebar-width);
        height: 100vh;
        background-color: var(--bg-secondary);
        color: var(--text-primary);
        border-left: 1px solid var(--border-color);
        padding: 15px;
        box-sizing: border-box;
        overflow-y: auto;
        transition: right 0.3s ease;
        z-index: 1000;
        visibility: hidden;
        opacity: 0;
      }

      #sidebar.visible {
        right: 0;
        visibility: visible;
        opacity: 1;
      }

      #sidebar h2 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.1em;
        color: var(--text-primary);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 8px;
      }

      #sidebar h3 {
        font-size: 1em;
        margin: 0;
        color: var(--text-secondary);
      }

      #sidebar h4 {
        font-size: 0.9em;
        margin: 8px 0;
        color: var(--text-secondary);
      }

      .tools-section {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .tools-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .tools-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .tool-item {
        background: var(--bg-main);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .tool-item:hover {
        border-color: var(--primary);
        background: linear-gradient(
          135deg,
          rgba(255, 0, 160, 0.1) 0%,
          rgba(150, 0, 255, 0.1) 100%
        );
      }

      .tool-item.active {
        border-color: var(--primary);
        background: linear-gradient(
          135deg,
          rgba(255, 0, 160, 0.2) 0%,
          rgba(150, 0, 255, 0.2) 100%
        );
      }

      .tool-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .tool-item-name {
        font-size: 0.9em;
        font-weight: bold;
        color: var(--text-primary);
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .tool-icon {
        color: var(--text-muted);
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .tool-item-actor {
        font-size: 0.9em;
        color: var(--text-muted);
      }

      .tool-item-description {
        font-size: 0.9em;
        color: var(--text-secondary);
        margin-top: 5px;
      }

      .tools-form {
        background: var(--bg-main);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 12px;
      }

      .tools-form.hidden {
        display: none;
      }

      .form-group {
        margin-bottom: 12px;
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 6px 8px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        font-family: var(--font-family);
        font-size: 0.9em;
      }

      .form-actions {
        display: flex;
        gap: 8px;
        justify-content: end;
      }

      .form-actions .action-button {
        padding: 6px 12px;
        font-size: 0.9em;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .saved-tools-section {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid var(--border-color);
      }

      .tool-actions {
        display: flex;
        gap: 4px;
      }

      .tool-action-btn {
        background: none;
        border: none;
        color: var(--text-muted);
        cursor: pointer;
        padding: 4px;
        transition: color 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
      }

      #add-tool-btn {
        padding: 4px 8px;
        font-size: 0.9em;
      }

      #sidebar-toggle {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 1001;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        height: 35px;
        width: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #sidebar-toggle:hover {
        background: var(--surrealist-gradient);
      }

      #input-container {
        position: fixed;
        bottom: 0;
        width: 800px;
        left: calc(50% - 400px);
        padding: 20px;
        background-color: var(--bg-main);
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
        border-radius: 10px 10px 0 0;
        border-top: 1px solid var(--border-color);
        display: flex;
        gap: 10px;
        align-items: flex-start;
        transition: all 0.3s ease;
        z-index: 999;
      }

      #input-container.sidebar-visible {
        left: calc(50% - 400px - var(--sidebar-width) / 2);
      }

      #chat-container {
        margin-bottom: 80px;
        display: flex;
        flex-direction: column;
        position: relative;
        z-index: 1;
      }

      #query-input {
        flex: 1;
        margin-right: 10px;
        padding: 10px;
        box-sizing: border-box;
        border-radius: 5px;
        background-color: var(--bg-main);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        resize: none;
        min-height: 40px;
        max-height: 200px;
        overflow-y: auto;
        font-family: var(--font-family);
      }

      .message {
        margin-bottom: 15px;
        padding: 12px;
        border-radius: 12px;
        max-width: 85%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        position: relative;
      }

      .user-message {
        background: var(--surrealist-gradient);
        align-self: flex-end;
        margin-left: auto;
        color: var(--text-primary);
        position: relative; /* For positioning the edit icon */
      }

      .user-message::before {
        content: "";
        position: absolute;
        left: -35px;
        top: 0;
        bottom: 0;
        width: 35px;
        pointer-events: auto;
      }

      .assistant-message {
        background-color: var(--bg-secondary);
        align-self: flex-start;
        border: 1px solid var(--border-color);
        color: var(--text-primary);
      }

      .system-message {
        background-color: #2a2a2d;
        align-self: flex-start;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .tool-message {
        background-color: #1a1a1d;
        align-self: flex-start;
        font-family: var(--font-family);
        position: relative;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .edit-icon {
        position: absolute;
        top: 50%;
        left: -35px;
        transform: translateY(-50%);
        background: var(--bg-secondary);
        color: var(--text-primary);
        padding: 5px;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        font-size: 1em;
        z-index: 100;
      }

      .user-message:hover .edit-icon,
      .edit-icon:hover {
        display: block;
      }

      .context-toggle {
        font-size: 0.8em;
        color: var(--text-muted);
        cursor: pointer;
        margin-top: 10px;
        padding: 5px 10px;
        background-color: var(--bg-secondary);
        border-radius: 4px;
        display: inline-block;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
        border: 1px solid var(--border-color);
      }

      .context-toggle:hover {
        background: var(--surrealist-gradient);
        color: var(--text-primary);
      }

      .context-content {
        display: none;
        margin-top: 10px;
        padding: 12px;
        background-color: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .context-content .message {
        margin: 8px 0;
        padding: 10px;
        font-size: 0.9em;
        max-width: 100%;
        background-color: var(--bg-main);
      }

      .context-content .user-message {
        background: linear-gradient(
          135deg,
          rgba(255, 0, 160, 0.15) 0%,
          rgba(150, 0, 255, 0.15) 100%
        );
        border: 1px solid rgba(255, 0, 160, 0.2);
        color: var(--text-primary);
      }

      .context-content .assistant-message {
        background-color: var(--bg-main);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .context-content .system-message {
        background-color: rgba(42, 42, 45, 0.5);
        border: 1px solid var(--border-color);
        color: var(--text-muted);
      }

      .context-content .tool-message {
        background-color: rgba(26, 26, 29, 0.8);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .context-content .message strong {
        display: block;
        margin-bottom: 5px;
        color: var(--text-muted);
      }

      .source-separator {
        border-top: 1px solid var(--border-color);
        margin-top: 10px;
        padding-top: 10px;
      }

      .source,
      .uri,
      .chunk {
        margin-bottom: 5px;
      }

      .tool-toggle {
        color: var(--text-muted);
        position: absolute;
        top: 16px;
        left: 8px;
        cursor: pointer;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
      }

      .tool-content {
        margin-left: 28px;
        display: none;
      }

      .tool-header {
        margin-left: 28px;
        padding: 4px 0;
        color: var(--text-muted);
      }

      .tool-function {
        margin-bottom: 8px;
        color: var(--text-secondary);
      }

      .tool-details pre {
        background-color: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border-radius: 6px;
        margin: 6px 0 14px 0;
        overflow-x: auto;
        border: 1px solid var(--border-color);
      }

      .tool-details code {
        font-size: 0.9em;
        color: #ff80cc;
      }

      #query-input:focus {
        border-color: var(--primary);
        outline: none;
        box-shadow: 0 0 0 2px rgba(255, 0, 160, 0.2);
      }

      .tool-toggle:hover {
        background: var(--surrealist-gradient);
        color: var(--text-primary);
      }

      .message,
      .context-toggle,
      .tool-toggle,
      #query-input {
        transition: background-color 0.2s, color 0.2s, border-color 0.2s,
          box-shadow 0.2s;
      }

      /* Scrollbar styling */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: var(--bg-secondary);
      }
      ::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: var(--primary-hover);
      }

      .action-button {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        padding: 10px 15px;
        border-radius: 5px;
        cursor: pointer;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .action-button:hover {
        background: var(--surrealist-gradient);
        border-color: var(--primary);
      }

      .action-button i {
        font-size: 1.2em;
      }

      /* Thinking process styles - simplified */
      .thinking-process {
        margin-bottom: 15px;
        position: relative;
        max-width: 85%;
        align-self: flex-start;
      }
      .thinking-header {
        display: inline-flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        color: var(--text-muted);
        font-size: 0.95rem;
        width: 100%;
      }

      .thinking-header i,
      .thinking-header .thinking-text {
        background: linear-gradient(
          to right,
          var(--text-muted) 25%,
          var(--primary) 50%,
          var(--text-muted) 75%
        );
        background-size: 200% 100%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: sweepingHighlight 2s infinite linear;
        transition: all 0.2s ease;
      }

      .thinking-text.static {
        background: none;
        -webkit-text-fill-color: var(--text-muted);
        color: var(--text-muted);
      }

      @keyframes sweepingHighlight {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }

      .thinking-content {
        margin-top: 8px;
        padding: 12px;
        display: none;
        white-space: pre-wrap;
        font-family: var(--font-family);
        font-size: 0.9em;
        color: var(--text-muted);
        background: linear-gradient(
          135deg,
          rgba(255, 0, 160, 0.05) 0%,
          rgba(150, 0, 255, 0.05) 100%
        );
        border: 1px solid rgba(255, 0, 160, 0.2);
        border-radius: 8px;
        line-height: 1.5;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        max-width: 100%;
        overflow-wrap: break-word;
      }

      .thinking-content.visible {
        display: block;
        animation: fadeIn 0.2s ease-in-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .action-button.active {
        background: var(--surrealist-gradient) !important;
        border-color: var(--primary) !important;
      }

      .action-button.active i {
        color: var(--text-primary) !important;
      }

      .message a {
        color: var(--primary);
        text-decoration: none;
        transition: color 0.2s;
      }

      .message a:hover {
        color: var(--primary-hover);
        text-decoration: underline;
      }

      .error-message {
        background-color: var(--bg-main);
        border: 1px solid var(--border-color);
        color: #ff6b6b;
        align-self: flex-start;
        padding: 12px;
        border-radius: 12px;
        max-width: 85%;
        margin-bottom: 15px;
        position: relative;
      }

      .error-toggle {
        color: var(--text-muted);
        position: absolute;
        top: 16px;
        left: 8px;
        cursor: pointer;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 0, 0, 0.1);
        border-radius: 4px;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
      }

      .error-toggle:hover {
        background: linear-gradient(
          135deg,
          rgba(255, 0, 0, 0.2) 0%,
          rgba(255, 0, 0, 0.3) 100%
        );
        color: #ff4444;
      }

      .error-header {
        margin-left: 28px;
        padding: 4px 0;
        color: #ff6b6b;
        font-weight: bold;
      }

      .error-content {
        margin-left: 28px;
        display: none;
        padding-top: 8px;
      }

      .error-item {
        margin-bottom: 8px;
        padding: 8px;
        background-color: rgba(255, 0, 0, 0.05);
        border: 1px solid rgba(255, 0, 0, 0.1);
        border-radius: 4px;
      }

      .typing-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        background: var(--primary);
        border-radius: 50%;
        margin-left: 2px;
        margin-right: 2px;
        vertical-align: middle;
        animation: pulse 1s infinite;
        white-space: pre;
      }

      @keyframes pulse {
        0% {
          opacity: 0.4;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.4;
        }
      }

      .assistant-message p {
        display: inline;
        margin: 0;
        padding: 0;
      }

      .message pre code {
        display: block;
        padding: 1em;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        overflow-x: auto;
        font-size: 0.9em;
        line-height: 1.4;
        tab-size: 2;
      }

      .message .chunk > p {
        margin: 0.5em 0;
        display: block;
      }

      .message .chunk > ul,
      .message .chunk > ol {
        margin: 0.5em 0;
        padding-left: 1.5em;
      }

      /* Add styles for disabled button state */
      .action-button[style*="cursor: not-allowed"]:hover {
        background: var(--bg-secondary) !important;
        border-color: var(--border-color) !important;
      }

      #sidebar .section {
        margin-bottom: 20px;
      }

      #sidebar label {
        display: block;
        margin-bottom: 5px;
        color: var(--text-secondary);
      }

      #sidebar input {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        background-color: var(--bg-main);
        color: var(--text-primary);
      }
    </style>
  </head>
  <body>
    <!-- Sidebar toggle button -->
    <button id="sidebar-toggle">
      <i class="fas fa-bars"></i>
    </button>

    <!-- Sidebar with helper Tools section -->
    <div id="sidebar">
      <h2>Tools</h2>
      <div class="section tools-section">
        <!-- Add New Actor form moved to top -->
        <div class="tools-form" id="tool-form">
          <h4>Add New Actor</h4>
          <div class="form-group">
            <input type="text" id="tool-actor" placeholder="Actor name" />
          </div>
          <div class="form-actions">
            <button id="save-tool-btn" class="action-button">
              <i class="fas fa-save"></i> Save
            </button>
          </div>
        </div>

        <div class="tools-header">
          <h3>Active Tools</h3>
        </div>

        <!-- Add the hidden input for tools actors -->
        <input type="hidden" id="tools-actors-input" value="" />

        <div id="active-tools-list" class="tools-list">
          <!-- Active tools will be listed here -->
        </div>

        <div class="saved-tools-section">
          <h3 style="margin-bottom: 10px">Available Tools</h3>
          <div id="saved-tools-list" class="tools-list">
            <!-- Saved tools will be listed here -->
          </div>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div id="main-content">
      <div id="chat-container"></div>
    </div>

    <!-- Input Container (moved outside main-content) -->
    <div id="input-container">
      <textarea
        id="query-input"
        placeholder="Enter your question here"
        rows="1"
      ></textarea>
      <button
        id="send-button"
        class="action-button"
        title="Chat with tools (Ctrl+Enter)"
      >
        <i class="fas fa-comments fa-wrench"></i>
      </button>
      <button
        id="think-button"
        class="action-button"
        title="Think deeply (Alt+Enter)"
      >
        <i class="fas fa-brain"></i>
      </button>
    </div>

    <script>
      // Remove any trailing slashes from the endpoint
      const RAG_ENDPOINT = window.location.origin;

      let isThinkingActive = false;
      let thinkingDiv = null;
      let thinkingContentDiv = null;
      let assistantTextBuffer = ""; // store user-visible assistant text
      let latestContext = null; // store context from the most recent chunk
      let contextSet = false; // track if we've appended the context yet
      let toolsEnabled = localStorage.getItem("toolsEnabled") === "true";
      let thinkEnabled = localStorage.getItem("thinkEnabled") === "true";
      let sidebarVisible = localStorage.getItem("sidebarVisible") === "true";

      const md = window.markdownit({ breaks: true });
      const chatContainer = document.getElementById("chat-container");
      const queryInput = document.getElementById("query-input");
      let messageHistory = [];
      let thinkingStartTime = null;

      mermaid.initialize({ startOnLoad: true });

      // Custom renderer for code fences (handles mermaid code blocks)
      md.renderer.rules.fence = function (tokens, idx) {
        const token = tokens[idx];
        const code = token.content.trim();
        if (token.info.trim() === "mermaid") {
          return '<div class="mermaid">' + code + "</div>";
        }
        return "<pre><code>" + md.utils.escapeHtml(code) + "</code></pre>";
      };

      // Updated helper to process a base64 image
      function processBase64Image(base64String, type = "jpeg") {
        base64String = base64String.trim();
        if (base64String.startsWith("data:image")) {
          return base64String;
        }
        try {
          atob(base64String); // verify Base64
          return `data:image/${type};base64,${base64String}`;
        } catch (e) {
          console.error("Invalid base64 string:", e);
          return null;
        }
      }

      // New helper: process message content (for both system and non-system messages)
      function processMessageContent(content, images = []) {
        let processedContent = "";
        let normalLines = [];
        let imageIndex = 0;

        // Flush accumulated normal text
        function flushNormalLines() {
          if (normalLines.length) {
            const joined = normalLines.join("\n").trim();
            if (joined) {
              try {
                // Try to detect JSON and pretty-print it
                const jsonObj = JSON.parse(joined);
                processedContent += `<pre><code>${JSON.stringify(
                  jsonObj,
                  null,
                  2
                )}</code></pre>`;
                console.log("Detected JSON content and formatted as code.");
              } catch (e) {
                // Not valid JSON; render as Markdown
                processedContent += md.render(joined);
              }
            }
            normalLines = [];
          }
        }

        // Process each line for markers
        const lines = content.split("\n");
        lines.forEach((line) => {
          const trimmedLine = line.trim();
          if (trimmedLine.startsWith("[URI:")) {
            flushNormalLines();
            let uri = trimmedLine.slice(5, -1).trim();
            processedContent += `<div class="uri">URI: ${uri}</div>`;
          } else if (trimmedLine.startsWith("Source:")) {
            flushNormalLines();
            let source = trimmedLine.slice(7).trim();
            processedContent += `<div class="source">Source: ${source}</div>`;
          } else if (trimmedLine.startsWith("[IMAGE:")) {
            flushNormalLines();
            let imageType = trimmedLine.slice(7, -1).trim();
            if (images && imageIndex < images.length) {
              let imageUrl = processBase64Image(images[imageIndex], imageType);
              if (imageUrl) {
                processedContent += `<div class="context-image"><img src="${imageUrl}" style="max-width: 100%; margin: 10px 0;"></div>`;
              }
              imageIndex++;
            } else {
              normalLines.push(line);
            }
          }
        });

        flushNormalLines();
        return processedContent;
      }

      // Replace the existing createContextSection with this updated version
      function createContextSection(context) {
        console.group("createContextSection");
        console.log("Input context:", context);

        if (!context?.length) {
          console.log("No context provided, returning empty string");
          console.groupEnd();
          return "";
        }

        let regularMessages = "";
        let systemMessage = "";
        let lastUserMessage = "";

        // Find the index of the last user message
        const lastUserIndex = [...context]
          .reverse()
          .findIndex((msg) => msg.role === "user");
        const lastMessageIndex =
          lastUserIndex !== -1 ? context.length - 1 - lastUserIndex : -1;
        console.log("Last user message index:", lastMessageIndex);

        // Process non-system messages (except the last user message)
        console.group("Processing regular messages");
        context.forEach((msg, index) => {
          if (msg.role !== "system" && index !== lastMessageIndex) {
            console.group(`Message ${index} (${msg.role})`);
            const roleClass = msg.role + "-message";
            const processedContent = processMessageContent(
              msg.content || "",
              msg.images || []
            );
            regularMessages += `
              <div class="message ${roleClass}">
                <div class="chunk">${processedContent}</div>
              </div>
            `;
            console.groupEnd();
          }
        });
        console.groupEnd();

        // Process system messages
        console.group("Processing system messages");
        context.forEach((msg, index) => {
          if (msg.role === "system") {
            console.group(`System message ${index}`);
            const roleClass = msg.role + "-message";
            let systemContent = msg.content.replace(
              /^\s*#{1,6}\s*ADDITIONAL CONTEXT:/im,
              "ADDITIONAL CONTEXT:"
            );
            const processedContent = processMessageContent(
              systemContent,
              msg.images || []
            );
            systemMessage += `
              <div class="message ${roleClass}">
                <strong>${
                  msg.role.charAt(0).toUpperCase() + msg.role.slice(1)
                }:</strong>
                <div class="chunk">${processedContent}</div>
              </div>
            `;
            console.groupEnd();
          }
        });
        console.groupEnd();

        // Process the last user message separately
        console.group("Processing last user message");
        if (lastMessageIndex !== -1) {
          const lastMsg = context[lastMessageIndex];
          const roleClass = lastMsg.role + "-message";
          const processedContent = processMessageContent(
            lastMsg.content || "",
            lastMsg.images || []
          );
          lastUserMessage = `
            <div class="message ${roleClass}">
              <strong>${
                lastMsg.role.charAt(0).toUpperCase() + lastMsg.role.slice(1)
              }:</strong>
              <div class="chunk">${processedContent}</div>
            </div>
          `;
        }
        console.groupEnd();

        const result = `
          <div class="context-container">
            <div class="context-toggle" onclick="toggleContext(this)">Show Context ◀</div>
            <div class="context-content">
              ${regularMessages}
              ${
                regularMessages && systemMessage
                  ? '<div class="source-separator"></div>'
                  : ""
              }
              ${systemMessage}
              ${
                (regularMessages || systemMessage) && lastUserMessage
                  ? '<div class="source-separator"></div>'
                  : ""
              }
              ${lastUserMessage}
            </div>
          </div>
        `;

        console.log("Final HTML length:", result.length);
        console.groupEnd();
        return result;
      }

      // Modified appendMessage to add an edit icon for user messages
      function appendMessage(sender, content, context = null) {
        const role =
          sender.toLowerCase() === "user"
            ? "user"
            : sender.toLowerCase() === "system"
            ? "system"
            : sender.toLowerCase() === "tool"
            ? "tool"
            : "assistant";

        messageHistory.push({ role: role, content: content });

        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${role}-message`;

        // For user messages, store the original content and history index.
        if (role === "user") {
          messageDiv.dataset.originalContent = content;
          messageDiv.dataset.msgIndex = messageHistory.length - 1;
        }

        const mainContent =
          sender === "User" ? md.utils.escapeHtml(content) : content;
        const rendered = md.render(mainContent);
        const contextSection =
          role === "assistant" ? createContextSection(context) : "";

        messageDiv.innerHTML = rendered + contextSection;

        // If this is a user message, append an edit icon.
        if (role === "user") {
          const editButton = document.createElement("div");
          editButton.className = "edit-icon";
          editButton.innerHTML = '<i class="fas fa-edit"></i>';
          editButton.addEventListener("click", function (e) {
            e.stopPropagation();
            editUserMessage(messageDiv);
          });
          messageDiv.appendChild(editButton);
        }

        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        window.scrollTo({
          top: document.body.scrollHeight,
          behavior: "smooth",
        });

        mermaid.init(undefined, document.querySelectorAll(".mermaid"));
      }

      // Modified sendQuery to optionally skip appending a new user message.
      async function sendQuery(endpoint = "/chat", skipUserAppend = false) {
        const queryText = queryInput.value.trim();
        if (!queryText) return;
        if (!skipUserAppend) {
          appendMessage("User", queryText);
        }
        queryInput.value = "";
        resizeTextarea();

        // Start thinking animation immediately for /think endpoint
        // or create empty assistant message for /chat
        if (endpoint === "/think") {
          thinkingDiv = createThinkingProcessContainer();
          chatContainer.appendChild(thinkingDiv);
          thinkingContentDiv = thinkingDiv.querySelector(".thinking-content");
          thinkingStartTime = Date.now();
          const thinkingText = thinkingDiv.querySelector(".thinking-text");
          if (thinkingText) {
            thinkingText.classList.remove("static");
          }
          isThinkingActive = true;
        } else if (endpoint === "/chat") {
          createOrUpdateAssistantMessage("");
        }

        // Reset state variables
        assistantTextBuffer = "";
        contextSet = false;
        latestContext = null;
        let errorBuffer = []; // New: Buffer to store errors during connection

        // Get tools actors list from sidebar input
        const toolsActorsInput = document.getElementById("tools-actors-input");
        const toolsActorsList = toolsActorsInput.value
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s !== "");
        if (toolsEnabled && toolsActorsList.length === 0) {
          alert("Please provide at least one tools actor.");
          toolsEnabled = false;
          updateToolButton();
          return;
        }

        const queryObject = {
          messages: messageHistory,
          model: "llama3.2",
          stream: true,
          tools_actors: toolsEnabled ? toolsActorsList : [],
        };

        try {
          const response = await fetch(`${RAG_ENDPOINT}${endpoint}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(queryObject),
          });

          if (!response.ok) {
            errorBuffer.push(`HTTP error! status: ${response.status}`);
          }

          // Display error container at the start if we have errors
          let errorDiv = null;
          if (errorBuffer.length > 0) {
            errorDiv = document.createElement("div");
            errorDiv.className = "message error-message";
            const errorContent = `
              <div class="error-toggle">▶</div>
              <div class="error-header">⚠️ ${errorBuffer.length} Error${
              errorBuffer.length > 1 ? "s" : ""
            } Occurred</div>
              <div class="error-content">
                ${errorBuffer
                  .map(
                    (error) => `
                  <div class="error-item">
                    <i class="fas fa-exclamation-circle"></i>
                    ${md.render(error)}
                  </div>
                `
                  )
                  .join("")}
              </div>
            `;
            errorDiv.innerHTML = errorContent;
            chatContainer.appendChild(errorDiv);
            initializeErrorToggles(errorDiv);
          }

          // We'll collect everything in a stream and process it
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            buffer += chunk;

            const lines = buffer.split("\n");
            buffer = lines.pop() || "";

            for (const line of lines) {
              if (!line.trim()) continue;
              try {
                const data = JSON.parse(line);

                // Store errors in buffer and update error display
                if (data.error) {
                  errorBuffer.push(data.error);
                  if (errorDiv) {
                    // Update existing error display
                    const errorContent = `
                      <div class="error-toggle">▶</div>
                      <div class="error-header">⚠️ ${errorBuffer.length} Error${
                      errorBuffer.length > 1 ? "s" : ""
                    } Occurred</div>
                      <div class="error-content">
                        ${errorBuffer
                          .map(
                            (error) => `
                          <div class="error-item">
                            <i class="fas fa-exclamation-circle"></i>
                            ${md.render(error)}
                          </div>
                        `
                          )
                          .join("")}
                      </div>
                    `;
                    errorDiv.innerHTML = errorContent;
                    initializeErrorToggles(errorDiv);
                  } else {
                    // Create new error display
                    errorDiv = document.createElement("div");
                    errorDiv.className = "message error-message";
                    const errorContent = `
                      <div class="error-toggle">▶</div>
                      <div class="error-header">⚠️ ${errorBuffer.length} Error${
                      errorBuffer.length > 1 ? "s" : ""
                    } Occurred</div>
                      <div class="error-content">
                        ${errorBuffer
                          .map(
                            (error) => `
                          <div class="error-item">
                            <i class="fas fa-exclamation-circle"></i>
                            ${md.render(error)}
                          </div>
                        `
                          )
                          .join("")}
                      </div>
                    `;
                    errorDiv.innerHTML = errorContent;
                    chatContainer.appendChild(errorDiv);
                    initializeErrorToggles(errorDiv);
                  }
                  continue;
                }

                processJsonLine(line);
              } catch (e) {
                console.error("Error processing JSON line:", e);
                console.error("Raw line content:", line);
                errorBuffer.push(`Error processing response: ${e.message}`);
                // Update error display with new error
                if (errorDiv) {
                  const errorContent = `
                    <div class="error-toggle">▶</div>
                    <div class="error-header">⚠️ ${errorBuffer.length} Error${
                    errorBuffer.length > 1 ? "s" : ""
                  } Occurred</div>
                    <div class="error-content">
                      ${errorBuffer
                        .map(
                          (error) => `
                        <div class="error-item">
                          <i class="fas fa-exclamation-circle"></i>
                          ${md.render(error)}
                        </div>
                      `
                        )
                        .join("")}
                    </div>
                  `;
                  errorDiv.innerHTML = errorContent;
                  initializeErrorToggles(errorDiv);
                } else {
                  errorDiv = document.createElement("div");
                  errorDiv.className = "message error-message";
                  const errorContent = `
                    <div class="error-toggle">▶</div>
                    <div class="error-header">⚠️ ${errorBuffer.length} Error${
                    errorBuffer.length > 1 ? "s" : ""
                  } Occurred</div>
                    <div class="error-content">
                      ${errorBuffer
                        .map(
                          (error) => `
                        <div class="error-item">
                          <i class="fas fa-exclamation-circle"></i>
                          ${md.render(error)}
                        </div>
                      `
                        )
                        .join("")}
                    </div>
                  `;
                  errorDiv.innerHTML = errorContent;
                  chatContainer.appendChild(errorDiv);
                  initializeErrorToggles(errorDiv);
                }
              }
            }
          }

          // leftover text after streaming
          if (assistantTextBuffer) {
            createOrUpdateAssistantMessage(assistantTextBuffer, latestContext);
          }

          // Stop the thinking animation if active
          if (thinkingDiv) {
            const thinkingText = thinkingDiv.querySelector(".thinking-text");
            if (thinkingText) {
              thinkingText.classList.add("static");
            }
          }

          // Remove typing indicator when done
          const indicators = document.querySelectorAll(".typing-indicator");
          indicators.forEach((indicator) => indicator.remove());

          mermaid.init(undefined, chatContainer.querySelectorAll(".mermaid"));
        } catch (error) {
          console.error("Error:", error);
          const errorDiv = document.createElement("div");
          errorDiv.className = "message error-message";
          const errorContent = `
            <div class="error-toggle">▶</div>
            <div class="error-header">⚠️ Error Occurred</div>
            <div class="error-content">
              <div class="error-item">
                <i class="fas fa-exclamation-circle"></i>
                ${md.render(error.toString())}
              </div>
            </div>
          `;
          errorDiv.innerHTML = errorContent;
          chatContainer.appendChild(errorDiv);
          initializeErrorToggles(errorDiv);
        }
      }

      // Function to handle editing a user message.
      function editUserMessage(messageDiv) {
        const originalContent =
          messageDiv.dataset.originalContent || messageDiv.innerText;

        // Get container and message dimensions before clearing content
        const containerRect = chatContainer.getBoundingClientRect();
        const messageRect = messageDiv.getBoundingClientRect();
        const rightOffset = containerRect.right - messageRect.right;

        // Clear current message content
        messageDiv.innerHTML = "";
        messageDiv.style.marginRight = rightOffset + "px";
        messageDiv.style.width = containerRect.width - rightOffset + "px";

        // Create edit container
        const editContainer = document.createElement("div");
        editContainer.style.position = "relative";
        editContainer.style.width = "100%";
        editContainer.style.display = "block";
        editContainer.style.minHeight = "150px";

        const textarea = document.createElement("textarea");
        textarea.value = originalContent;
        textarea.style.width = "100%";
        textarea.style.height = "150px";
        textarea.style.boxSizing = "border-box";
        textarea.style.padding = "10px";
        textarea.style.border = "1px solid var(--border-color)";
        textarea.style.borderRadius = "5px";
        textarea.style.backgroundColor = "var(--bg-main)";
        textarea.style.color = "var(--text-primary)";
        textarea.style.marginBottom = "60px";

        editContainer.appendChild(textarea);

        const buttonContainer = document.createElement("div");
        buttonContainer.style.position = "absolute";
        buttonContainer.style.bottom = "10px";
        buttonContainer.style.right = "10px";
        buttonContainer.style.display = "flex";
        buttonContainer.style.gap = "5px";

        const cancelButton = document.createElement("button");
        cancelButton.textContent = "Cancel";
        cancelButton.className = "action-button";
        cancelButton.style.margin = "0";

        const saveButton = document.createElement("button");
        saveButton.textContent = "Send";
        saveButton.className = "action-button";
        saveButton.style.margin = "0";

        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(saveButton);
        editContainer.appendChild(buttonContainer);

        messageDiv.appendChild(editContainer);

        cancelButton.addEventListener("click", function () {
          messageDiv.innerHTML = md.render(
            md.utils.escapeHtml(originalContent)
          );
          messageDiv.dataset.originalContent = originalContent;
          messageDiv.style.marginRight = "";
          messageDiv.style.width = "";
          const editButton = document.createElement("div");
          editButton.className = "edit-icon";
          editButton.innerHTML = '<i class="fas fa-edit"></i>';
          editButton.addEventListener("click", function (e) {
            e.stopPropagation();
            editUserMessage(messageDiv);
          });
          messageDiv.appendChild(editButton);
        });

        saveButton.addEventListener("click", function () {
          const newContent = textarea.value.trim();
          if (!newContent) return;
          const indexInChat = Array.from(chatContainer.children).indexOf(
            messageDiv
          );
          while (chatContainer.children.length > indexInChat + 1) {
            chatContainer.removeChild(chatContainer.lastChild);
          }
          const msgIndex = parseInt(messageDiv.dataset.msgIndex, 10);
          messageHistory = messageHistory.slice(0, msgIndex + 1);
          messageHistory[msgIndex].content = newContent;
          messageDiv.innerHTML = md.render(md.utils.escapeHtml(newContent));
          messageDiv.style.marginRight = "";
          messageDiv.style.width = "";
          messageDiv.dataset.originalContent = newContent;
          const editButton = document.createElement("div");
          editButton.className = "edit-icon";
          editButton.innerHTML = '<i class="fas fa-edit"></i>';
          editButton.addEventListener("click", function (e) {
            e.stopPropagation();
            editUserMessage(messageDiv);
          });
          messageDiv.appendChild(editButton);
          queryInput.value = newContent;
          sendQuery(thinkEnabled ? "/think" : "/chat", true);
        });
      }

      function processJsonLine(json_line) {
        const data = JSON.parse(json_line);

        if (data.context) {
          latestContext = data.context;
        }

        if (!data.message?.content) {
          if (data.done && assistantTextBuffer) {
            createOrUpdateAssistantMessage(assistantTextBuffer, latestContext);
            messageHistory.push({
              role: "assistant",
              content: assistantTextBuffer,
              images: data.message?.images,
            });
          }
          return;
        }

        if (data.message.role === "system" || data.message.role === "tool") {
          handleSpecialRole(data.message);
          return;
        }

        if (data.message.role === "assistant") {
          let chunk = data.message.content;
          let idx = 0;

          while (idx < chunk.length) {
            if (!isThinkingActive) {
              const openPos = chunk.indexOf("<think>", idx);
              if (openPos === -1) {
                const visiblePart = chunk.substring(idx);
                assistantTextBuffer += visiblePart;
                idx = chunk.length;
              } else {
                const visiblePart = chunk.substring(idx, openPos);
                if (visiblePart.trim()) {
                  assistantTextBuffer += visiblePart;
                }
                idx = openPos + 7;
                if (!thinkingDiv) {
                  thinkingDiv = createThinkingProcessContainer();
                  chatContainer.appendChild(thinkingDiv);
                  thinkingContentDiv =
                    thinkingDiv.querySelector(".thinking-content");
                  thinkingStartTime = Date.now();
                  const thinkingText =
                    thinkingDiv.querySelector(".thinking-text");
                  if (thinkingText) {
                    thinkingText.classList.remove("static");
                  }
                }
                isThinkingActive = true;
              }
            } else {
              const closePos = chunk.indexOf("</think>", idx);
              if (closePos === -1) {
                const thoughtChunk = chunk.substring(idx);
                appendThinkingChunk(thoughtChunk, thinkingContentDiv);
                idx = chunk.length;
              } else {
                const thoughtChunk = chunk.substring(idx, closePos);
                if (thoughtChunk.trim()) {
                  appendThinkingChunk(thoughtChunk, thinkingContentDiv);
                }
                idx = closePos + 8;
                isThinkingActive = false;
                if (assistantTextBuffer.trim().length > 0) {
                  createOrUpdateAssistantMessage(
                    assistantTextBuffer,
                    latestContext
                  );
                }
                if (thinkingDiv && thinkingStartTime) {
                  const duration = (
                    (Date.now() - thinkingStartTime) /
                    1000
                  ).toFixed(1);
                  const thinkingText =
                    thinkingDiv.querySelector(".thinking-text");
                  if (thinkingText) {
                    thinkingText.textContent = `Thought for ${duration}s`;
                    thinkingText.classList.add("static");
                  }
                  thinkingStartTime = null;
                }
              }
            }
          }

          if (!isThinkingActive && assistantTextBuffer.length > 0) {
            createOrUpdateAssistantMessage(assistantTextBuffer, latestContext);
          }

          if (data.done) {
            const indicators = document.querySelectorAll(".typing-indicator");
            indicators.forEach((indicator) => indicator.remove());
            if (
              assistantTextBuffer &&
              !messageHistory.some(
                (msg) =>
                  msg.role === "assistant" &&
                  msg.content === assistantTextBuffer
              )
            ) {
              messageHistory.push({
                role: "assistant",
                content: assistantTextBuffer,
                images: data.message?.images,
              });
            }
            createOrUpdateAssistantMessage(assistantTextBuffer, latestContext);
            assistantTextBuffer = "";
          }
        }
      }

      function handleSpecialRole(msg) {
        const lastMessageDiv = chatContainer.lastElementChild;
        const lastMessageRole =
          lastMessageDiv?.className.match(/(\w+)-message/)?.[1];

        if (msg.role === "tool") {
          if (lastMessageRole === "assistant") {
            const assistantContent = lastMessageDiv.querySelector(
              "div:not(.context-container):not(.thinking-process)"
            );
            if (assistantContent && !assistantContent.textContent.trim()) {
              lastMessageDiv.remove();
            }
          }
          const toolData = JSON.parse(msg.content);
          const specialMessageDiv = document.createElement("div");
          specialMessageDiv.className = "message tool-message";
          const formattedContent = `
            <div class="tool-toggle">▶</div>
            <div class="tool-header">🔧 Tool Call: ${toolData.tool}</div>
            <div class="tool-content">
              <div class="tool-details">
                <strong>Arguments:</strong>
                <pre><code>${JSON.stringify(
                  toolData.call.function.arguments,
                  null,
                  2
                )}</code></pre>
                <strong>Response:</strong>
                <pre><code>${JSON.stringify(
                  toolData.response,
                  null,
                  2
                )}</code></pre>
              </div>
            </div>
          `;
          specialMessageDiv.innerHTML = formattedContent;
          chatContainer.appendChild(specialMessageDiv);
          initializeToolToggles(specialMessageDiv);
        } else {
          if (lastMessageDiv && lastMessageRole === "system") {
            lastMessageDiv.innerHTML +=
              '<div class="source-separator"></div>' + md.render(msg.content);
          } else {
            const systemDiv = document.createElement("div");
            systemDiv.className = "message system-message";
            systemDiv.innerHTML = md.render(msg.content);
            chatContainer.appendChild(systemDiv);
          }
        }
      }

      function createOrUpdateAssistantMessage(visibleText, context = null) {
        const lastMessageDiv = chatContainer.lastElementChild;
        const lastMessageRole =
          lastMessageDiv?.className.match(/(\w+)-message/)?.[1];

        let assistantBlock;
        let assistantContent;

        if (lastMessageRole === "assistant") {
          assistantBlock = lastMessageDiv;
          assistantContent = assistantBlock.querySelector(
            "div:not(.context-container):not(.thinking-process)"
          );
          if (!assistantContent) {
            assistantContent = document.createElement("div");
            assistantBlock.appendChild(assistantContent);
          }
        } else {
          assistantBlock = document.createElement("div");
          assistantBlock.className = "message assistant-message";
          assistantContent = document.createElement("div");
          assistantBlock.appendChild(assistantContent);
          chatContainer.appendChild(assistantBlock);
        }

        const existingIndicators =
          assistantContent.querySelectorAll(".typing-indicator");
        existingIndicators.forEach((indicator) => indicator.remove());

        assistantContent.innerHTML = md.render(visibleText || "");
        const typingIndicator = document.createElement("span");
        typingIndicator.className = "typing-indicator";

        let lastContentElement = assistantContent;
        const walker = document.createTreeWalker(
          assistantContent,
          NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
          {
            acceptNode: function (node) {
              if (
                node.nodeType === Node.TEXT_NODE &&
                !node.textContent.trim()
              ) {
                return NodeFilter.FILTER_SKIP;
              }
              if (node.classList?.contains("typing-indicator")) {
                return NodeFilter.FILTER_SKIP;
              }
              return NodeFilter.FILTER_ACCEPT;
            },
          }
        );

        while (walker.nextNode()) {
          lastContentElement = walker.currentNode;
        }

        if (
          lastContentElement.nodeType === Node.TEXT_NODE ||
          getComputedStyle(lastContentElement).display === "inline"
        ) {
          lastContentElement.parentNode.appendChild(typingIndicator);
        } else {
          lastContentElement.appendChild(typingIndicator);
        }

        if (!contextSet && context?.length) {
          const contextSection = createContextSection(context);
          if (contextSection) {
            const contextDiv = document.createElement("div");
            contextDiv.innerHTML = contextSection;
            assistantBlock.appendChild(contextDiv);
          }
          contextSet = true;
        }

        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      function createThinkingProcessContainer() {
        const div = document.createElement("div");
        div.className = "thinking-process";
        div.innerHTML = `
          <div class="thinking-header" onclick="toggleThinking(this)">
            <span class="thinking-text">Thinking...</span>
          </div>
          <div class="thinking-content"></div>
        `;
        return div;
      }

      function appendThinkingChunk(text, contentDiv) {
        if (!contentDiv) return;
        const cleanedText = text.replace(/<\/?think>/g, "");
        contentDiv.textContent += cleanedText;
      }

      window.toggleContext = function (toggleElement) {
        const contextContent = toggleElement.nextElementSibling;
        const isHidden =
          contextContent.style.display === "none" ||
          !contextContent.style.display;
        contextContent.style.display = isHidden ? "block" : "none";
        toggleElement.textContent = isHidden
          ? "Hide Context ▼"
          : "Show Context ◀";
      };

      window.toggleThinking = function (header) {
        const content = header.nextElementSibling;
        content.classList.toggle("visible");
      };

      function initializeToolToggles(container) {
        container.querySelectorAll(".tool-toggle").forEach((toggle) => {
          if (!toggle.hasListener) {
            toggle.addEventListener("click", function () {
              const content = this.parentElement.querySelector(".tool-content");
              const isHidden =
                content.style.display === "none" || !content.style.display;
              content.style.display = isHidden ? "block" : "none";
              this.textContent = isHidden ? "▼" : "▶";
            });
            toggle.hasListener = true;
          }
        });
      }

      function resizeTextarea() {
        queryInput.style.height = "auto";
        queryInput.style.height = queryInput.scrollHeight + "px";
      }

      queryInput.addEventListener("input", resizeTextarea);

      queryInput.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          if (e.shiftKey) {
            resizeTextarea();
            return;
          }
          if (e.ctrlKey) {
            e.preventDefault();
            const toolsActorsInput =
              document.getElementById("tools-actors-input");
            const toolsActorsList = toolsActorsInput.value
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s !== "");

            // Only toggle if we have tools
            if (toolsActorsList.length > 0) {
              toolsEnabled = !toolsEnabled;
              updateToolButton();
            }
            return;
          }
          if (e.altKey) {
            e.preventDefault();
            thinkEnabled = !thinkEnabled;
            updateThinkButton();
            return;
          }
          e.preventDefault();
          const endpoint = thinkEnabled ? "/think" : "/chat";
          await sendQuery(endpoint);
        }
      });

      document
        .getElementById("send-button")
        .addEventListener("click", async () => {
          const toolsActorsInput =
            document.getElementById("tools-actors-input");
          const toolsActorsList = toolsActorsInput.value
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s !== "");

          // Only toggle if we have tools
          if (toolsActorsList.length > 0) {
            toolsEnabled = !toolsEnabled;
            updateToolButton();
          }
        });

      document.getElementById("think-button").addEventListener("click", () => {
        thinkEnabled = !thinkEnabled;
        updateThinkButton();
      });

      function updateToolButton() {
        const toolButton = document.getElementById("send-button");
        const toolsActorsInput = document.getElementById("tools-actors-input");
        const toolsActorsList = toolsActorsInput.value
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s !== "");

        // Disable tools if no actors are available
        if (toolsActorsList.length === 0) {
          toolsEnabled = false;
          toolButton.classList.remove("active");
          toolButton.style.opacity = "0.5";
          toolButton.style.cursor = "not-allowed";
          toolButton.title =
            "Please add at least one tool in the sidebar to enable tools";
        } else {
          toolButton.style.opacity = "1";
          toolButton.style.cursor = "pointer";
          toolButton.classList.toggle("active", toolsEnabled);
          toolButton.title = toolsEnabled ? "Tools enabled" : "Tools disabled";
        }

        localStorage.setItem("toolsEnabled", toolsEnabled);
      }

      function updateThinkButton() {
        const thinkButton = document.getElementById("think-button");
        thinkButton.classList.toggle("active", thinkEnabled);
        thinkButton.title = thinkEnabled
          ? "Think mode enabled"
          : "Think mode disabled";
        localStorage.setItem("thinkEnabled", thinkEnabled);
      }

      // Initialize sidebar state
      function initializeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const mainContent = document.getElementById("main-content");
        const inputContainer = document.getElementById("input-container");

        if (sidebarVisible) {
          sidebar.classList.add("visible");
          mainContent.classList.add("sidebar-visible");
          inputContainer.classList.add("sidebar-visible");
        }

        // Initialize tools management
        initializeToolsManagement();
      }

      // Tool Management
      function initializeToolsManagement() {
        const saveToolBtn = document.getElementById("save-tool-btn");

        // Load saved tools from localStorage
        loadSavedTools();
        loadActiveTools();

        // Event Listeners
        saveToolBtn.addEventListener("click", saveTool);
      }

      function clearToolForm() {
        document.getElementById("tool-actor").value = "";
      }

      function saveTool() {
        const actor = document.getElementById("tool-actor").value.trim();

        if (!actor) {
          alert("Actor name is required!");
          return;
        }

        const tool = {
          id: Date.now().toString(),
          actor,
          active: false,
        };

        // Save to localStorage
        const savedTools = getSavedTools();
        savedTools.push(tool);
        localStorage.setItem("savedTools", JSON.stringify(savedTools));

        // Add to saved tools list
        addToolToSavedList(tool);

        // Clear the form input
        clearToolForm();
      }

      function getSavedTools() {
        const tools = localStorage.getItem("savedTools");
        return tools ? JSON.parse(tools) : [];
      }

      function getActiveTools() {
        const tools = localStorage.getItem("activeTools");
        return tools ? JSON.parse(tools) : [];
      }

      function loadSavedTools() {
        const savedToolsList = document.getElementById("saved-tools-list");
        savedToolsList.innerHTML = "";
        const savedTools = getSavedTools();
        const activeTools = getActiveTools();

        // Filter out active tools from saved tools display
        const availableTools = savedTools.filter(
          (saved) => !activeTools.some((active) => active.id === saved.id)
        );

        availableTools.forEach((tool) => addToolToSavedList(tool));
      }

      function loadActiveTools() {
        const activeToolsList = document.getElementById("active-tools-list");
        activeToolsList.innerHTML = "";
        const tools = getActiveTools();
        tools.forEach((tool) => addToolToActiveList(tool));
      }

      function addToolToActiveList(tool) {
        const activeToolsList = document.getElementById("active-tools-list");
        const toolElement = createToolElement(tool, true);
        activeToolsList.appendChild(toolElement);
      }

      function addToActive(tool) {
        const activeTools = getActiveTools();
        if (!activeTools.some((t) => t.id === tool.id)) {
          activeTools.push(tool);
          localStorage.setItem("activeTools", JSON.stringify(activeTools));
          addToolToActiveList(tool);
          // Refresh saved tools list to remove the activated tool
          loadSavedTools();
          updateToolsActors();
          updateToolButton();
        }
      }

      function createToolElement(tool, isActive = false) {
        const toolElement = document.createElement("div");
        toolElement.className = `tool-item${isActive ? " active" : ""}`;
        toolElement.dataset.toolId = tool.id;
        toolElement.innerHTML = `
          <div class="tool-item-header">
            <span class="tool-icon"><i class="fas fa-wrench"></i></span>
            <span class="tool-item-name">${tool.actor}</span>
            <div class="tool-actions">
              ${
                isActive
                  ? `
                <button class="tool-action-btn remove-tool" title="Remove">
                  <i class="fas fa-times"></i>
                </button>
              `
                  : `
                <button class="tool-action-btn add-tool" title="Add to Active">
                  <i class="fas fa-plus"></i>
                </button>
                <button class="tool-action-btn delete-tool" title="Delete">
                  <i class="fas fa-trash"></i>
                </button>
              `
              }
            </div>
          </div>
        `;

        // Add event listeners
        const actions = toolElement.querySelector(".tool-actions");
        if (isActive) {
          actions
            .querySelector(".remove-tool")
            .addEventListener("click", () => removeFromActive(tool));
        } else {
          actions
            .querySelector(".add-tool")
            .addEventListener("click", () => addToActive(tool));
          actions
            .querySelector(".delete-tool")
            .addEventListener("click", () => deleteTool(tool));
        }

        return toolElement;
      }

      function addToolToSavedList(tool) {
        const savedToolsList = document.getElementById("saved-tools-list");
        const toolElement = createToolElement(tool, false);
        savedToolsList.appendChild(toolElement);
      }

      function removeFromActive(tool) {
        const activeTools = getActiveTools().filter((t) => t.id !== tool.id);
        localStorage.setItem("activeTools", JSON.stringify(activeTools));
        loadActiveTools();
        // Refresh saved tools list to show the deactivated tool
        loadSavedTools();
        updateToolsActors();
        updateToolButton();
      }

      function deleteTool(tool) {
        const savedTools = getSavedTools().filter((t) => t.id !== tool.id);
        localStorage.setItem("savedTools", JSON.stringify(savedTools));

        // Also remove from active if present
        const activeTools = getActiveTools().filter((t) => t.id !== tool.id);
        localStorage.setItem("activeTools", JSON.stringify(activeTools));

        loadSavedTools();
        loadActiveTools();
        updateToolsActors();
        updateToolButton();
      }

      function updateToolsActors() {
        const activeTools = getActiveTools();
        const actors = activeTools.map((tool) => tool.actor);
        const toolsActorsInput = document.getElementById("tools-actors-input");
        toolsActorsInput.value = actors.join(", ");
        localStorage.setItem("toolsActors", actors.join(", "));

        // Update tools state based on actors
        if (actors.length === 0) {
          toolsEnabled = false;
        }
        updateToolButton();
      }

      // Toggle sidebar visibility
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const mainContent = document.getElementById("main-content");
        const inputContainer = document.getElementById("input-container");

        sidebarVisible = !sidebarVisible;
        localStorage.setItem("sidebarVisible", sidebarVisible);

        sidebar.classList.toggle("visible");
        mainContent.classList.toggle("sidebar-visible");
        inputContainer.classList.toggle("sidebar-visible");

        // Force recalculation of chat container scroll
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      // Add event listener for sidebar toggle
      document
        .getElementById("sidebar-toggle")
        .addEventListener("click", toggleSidebar);

      // Initialize sidebar on page load
      document.addEventListener("DOMContentLoaded", () => {
        initializeSidebar();

        // Load stored tools state
        const storedToolsEnabled = localStorage.getItem("toolsEnabled");
        const toolsActorsInput = document.getElementById("tools-actors-input");
        const storedToolsActors = localStorage.getItem("toolsActors");

        // First load the tools actors
        if (storedToolsActors) {
          toolsActorsInput.value = storedToolsActors;
        }

        // Then set the tools state
        if (storedToolsEnabled !== null) {
          toolsEnabled = storedToolsEnabled === "true";

          // Validate the state against available tools
          const toolsActorsList = toolsActorsInput.value
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s !== "");

          if (toolsActorsList.length === 0) {
            toolsEnabled = false;
          }
        }

        updateToolButton();
        updateThinkButton();

        // Add change listener for tools actors
        toolsActorsInput.addEventListener("change", function () {
          localStorage.setItem("toolsActors", toolsActorsInput.value);
          updateToolButton();
        });
      });

      // Initialize styles for disabled button state
      (function () {
        const style = document.createElement("style");
        style.textContent = `
          .action-button[style*="cursor: not-allowed"]:hover {
            background: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
          }
        `;
        document.head.appendChild(style);
      })();

      function initializeErrorToggles(container) {
        container.querySelectorAll(".error-toggle").forEach((toggle) => {
          if (!toggle.hasListener) {
            toggle.addEventListener("click", function () {
              const content =
                this.parentElement.querySelector(".error-content");
              const isHidden =
                content.style.display === "none" || !content.style.display;
              content.style.display = isHidden ? "block" : "none";
              this.textContent = isHidden ? "▼" : "▶";
            });
            toggle.hasListener = true;
          }
        });
      }
    </script>
  </body>
</html>
